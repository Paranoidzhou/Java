<!DOCTYPE html>
<html>
<head>
<title>bin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>二进制</h1>
<h2>初识二进制</h2>
<p>案例:</p>
<pre><code>/*
 * 认识一下2进制
 * 数据在计算机中是2进制的!
 * int long 等数据都是2进制的!
 */
int n = 50;//110010
//toBinaryString 将一个在内存中实际的2进制
//转换为字符串! 就是输出n在内存中的情况
System.out.println(
        Integer.toBinaryString(n));
</code></pre>

<h2>什么是2进制</h2>
<p>逢二进一的计数规则!</p>
<p><img src="imgs/2.png" /></p>
<p>Java 利用了API解决了2进制的输入与输出问题:</p>
<p><img src="imgs/bin.png" /></p>
<p>案例:</p>
<pre><code>/**
 * 输出 0 ~ 50 全部的 2进制数
 * 手工验证:每个2进制数字的值
 */
for(int i=0;i&lt;=50;i++){
    String bin=Integer.toBinaryString(i);
    bin = StringUtils.leftPad(bin,32,'0');
    System.out.println(bin);
}
</code></pre>

<h2>16进制</h2>
<p>逢16进一的计数规则!</p>
<p>其本质目的是用于简写2进制. 2进制从后向前(低位到高位)每4位可以缩写为一个16进制数.</p>
<p>计算机专业人员需要使用2进制时候, 都是采用16进制缩写!</p>
<p><img src="imgs/hex.png" /></p>
<p>案例:</p>
<pre><code>/**
 * 16进制用于缩写2进制数
 * 01110010 01001111 11010101 01010101
 * 7   2    4   f    d   5    5   5
*/
int n = 0x724fd555;
System.out.println(
    Integer.toBinaryString(n));
</code></pre>

<h2>补码</h2>
<p>补码是计算机中处理 <strong>有符号数</strong> 的编码规则</p>
<p>补码的编码核心思想: 将固定位数的2进制数分一半作为负数使用.</p>
<p>4位数补码为例!</p>
<p><img src="imgs/3.png" /></p>
<p>案例:</p>
<pre><code>/*
 * 查看一个数据的补码
 */
int n = -3;
System.out.println(
        Integer.toBinaryString(n));

//Java 利用parseInt将10进制负数转换为补码
int i = Integer.parseInt(&quot;-3&quot;);
System.out.println(
        Integer.toBinaryString(i));
System.out.println(i); //toString(i)
</code></pre>

<p>案例:</p>
<pre><code>/* 
 * 补码特殊值的规律
 */

int n = 0; //0x0;
int m = -1;//0xffffffff;
int max = Integer.MAX_VALUE;//0x7fffffff
int min = Integer.MIN_VALUE;//0x80000000
System.out.println(
        Integer.toBinaryString(n));
System.out.println(
        Integer.toBinaryString(m));
System.out.println(
        Integer.toBinaryString(max));
System.out.println(
        Integer.toBinaryString(min));

long l = Long.MAX_VALUE;
System.out.println(
    Long.toBinaryString(l)); 
</code></pre>

<p>案例:</p>
<pre><code>/**
 * 输出 -50 ~ 50 之间的补码
 */
for(int i=-50; i&lt;=50; i++){
    System.out.println(
        StringUtils.leftPad(
        Integer.toBinaryString(i), 
        32, '0'));
}
</code></pre>

<p>案例:</p>
<pre><code>/*
 * 补码的互补对称现象 -n=~n+1
 */
int n = 8;
int m = ~n+1;
System.out.println(m); //-8
//分析计算原理:
System.out.println(StringUtils.leftPad(
    Integer.toBinaryString(n),32,'0'));
System.out.println(StringUtils.leftPad(
    Integer.toBinaryString(~n),32,'0'));
System.out.println(StringUtils.leftPad(
    Integer.toBinaryString(~n+1),32,'0'));
</code></pre>

<p>经典面试题目:</p>
<pre><code>System.out.println(~4+1);
如上代码的结果(  )
A.-2 B.-3 C.-4 D.-5
答案: C

System.out.println(~-4+1);
如上代码的结果(  )
A.2 B.3 C.4 D.5
答案: C

System.out.println(~-4);
如上代码的结果(  )
A.2 B.3 C.4 D.5
答案: B
</code></pre>

<h2>2进制运算符</h2>
<p>运算符: <code>&amp;</code> <code>|</code> <code>~</code> <code>&gt;&gt;&gt;</code> <code>&gt;&gt;</code> <code>&lt;&lt;</code> </p>
<h3>&amp; 与运算</h3>
<p>运算规则(逻辑乘法):</p>
<pre><code>0 &amp; 0 -&gt; 0
0 &amp; 1 -&gt; 0
1 &amp; 0 -&gt; 0
1 &amp; 1 -&gt; 1
</code></pre>

<blockquote>
<p>有0得0 </p>
</blockquote>
<p>两个数据对其位数进行按位 &amp; 计算</p>
<pre><code>n =   00011101 01011110 10111110 10101001
m =   00000000 00000000 00000000 11111111
k=n&amp;m 00000000 00000000 00000000 10101001
</code></pre>

<blockquote>
<p>如上计算的意义: k 是 n 的 低8位数, m称为掩码(Mask), 如上程序中m称为8位 Mask</p>
</blockquote>
<p>代码:</p>
<pre><code>int n = 0x1d5ebea9;
int m = 0xff;
int k = n&amp;m;
//按照2进制输出 n m k, 为了显示友好可以补全32位.
</code></pre>

<h3>| 或运算</h3>
<p>规则(逻辑加法):</p>
<pre><code>0 | 0 -&gt; 0
0 | 1 -&gt; 1
1 | 0 -&gt; 1
1 | 1 -&gt; 1
</code></pre>

<blockquote>
<p>有1得1 </p>
</blockquote>
<p>两个数字对其位置, 每一位进行 | 计算.</p>
<pre><code>n =   00000000 00000000 00000000 11011010
m =   00000000 00000000 11010011 00000000
k=n|m 00000000 00000000 11010011 11011010 
</code></pre>

<blockquote>
<p>如上计算的意义:将两个8位数进行了拼接计算</p>
</blockquote>
<p>代码验证:</p>
<pre><code>int n = 0xda;
int m = 0xd300;
int k = n|m;
//按照2进制输出 n m k
</code></pre>

<p>举个栗子: 将两个8位数拼接为一个16位数</p>
<pre><code>int n = 0xda;
int m = 0xd3;
int k = (m&lt;&lt;8) | n

n =   00000000 00000000 00000000 11011010
m =   00000000 00000000 00000000 11010011
m&lt;&lt;8  00000000 00000000 11010011 00000000
</code></pre>

<h3><code>&lt;&lt;</code> 左移计算</h3>
<p>运算规则: 将一个数字的整体向左移动, 高位自动溢出(舍弃), 低位补0</p>
<p>举个栗子:</p>
<pre><code>n =    00100101 01001001 11110101 01010101
m=n&lt;&lt;1 0100101 01001001 11110101 010101010
k=n&lt;&lt;2 100101 01001001 11110101 0101010100
g=n&lt;&lt;8 01001001 11110101 01010101 00000000
</code></pre>

<p>代码验证:</p>
<pre><code>int n = 0x2549f555;
int m = n&lt;&lt;1;
int k = n&lt;&lt;2;
int g = n&lt;&lt;8;
//按照2进制输出 n m k g, 补齐32位
</code></pre>

<p>案例:</p>
<pre><code>将4个byte数据拼接为一个int数据

b1 = 00000000 00000000 00000000 11011101
b2 = 00000000 00000000 00000000 00110111
b3 = 00000000 00000000 00000000 11011110
b4 = 00000000 00000000 00000000 10001001

int = b4 b3 b2 b1
n  = 10001001 11011110 00110111 11011101

n = (b4&lt;&lt;24)|(b3&lt;&lt;16)|(b2&lt;&lt;8)|b1
</code></pre>

<h3><code>&gt;&gt;&gt;</code> 右移位计算</h3>
<p>运算规则:</p>
<pre><code>数字整体向右移动, 低位自动溢出, 高位补0
</code></pre>

<p>举个栗子:</p>
<pre><code>n =      00111011 01111011 00111101 10011111
m=n&gt;&gt;&gt;1  000111011 01111011 00111101 1001111 
k=n&gt;&gt;&gt;2  0000111011 01111011 00111101 100111
g=n&gt;&gt;&gt;8  00000000 00111011 01111011 00111101
</code></pre>

<p>代码验证:</p>
<pre><code>...
</code></pre>

<p>案例: 利用右移位计算将一个int数据拆分为4个byte</p>
<pre><code>将如下n
n =  01011101 11011110 00110100 10100111
     b4       b3       b2       b1
拆分为: b4 b3 b2 b1    
b4 = 00000000 00000000 00000000 01011101 
b3 = 00000000 00000000 00000000 11011110
b2 = 00000000 00000000 00000000 00110100
b1 = 00000000 00000000 00000000 10100111

b1 = n &amp; 0xff;
b2 = (n &gt;&gt;&gt; 8) &amp; 0xff;
b3 = (n &gt;&gt;&gt; 16) &amp; 0xff;
b4 = (n &gt;&gt;&gt; 24) &amp; 0xff;
</code></pre>

<h3>移位计算的数学意义</h3>
<p>回顾: 移动小数点计算</p>
<pre><code>一个10进制数  2341132.  将小数点向右移动一次
得到         23411320. 数字扩大10倍 移动两次扩大100倍
如果看做小数点不动的话, 数字向左移动, 数字向左移动一次数字扩大10倍
</code></pre>

<p>推广: 2进制时候如上的规律依然存在, 2进制数据整体向左移动一次, 数字扩大2倍!</p>
<pre><code>n =     00000000 00000000 00000000 00110010   50
m=n&lt;&lt;1  0000000 00000000 00000000 001100100  100
k=n&lt;&lt;2  000000 00000000 00000000 0011001000  200
...
</code></pre>

<p>验证:</p>
<pre><code>int n = 50;
int m = n&lt;&lt;1;
int k = n&lt;&lt;2;
</code></pre>

<p>经典面试题目:</p>
<pre><code>可以优化计算 n*8 为 (    )
答案: n &lt;&lt; 3
</code></pre>

<h3><code>&gt;&gt;</code> 和 <code>&gt;&gt;&gt;</code> 的区别</h3>
<p><code>&gt;&gt;&gt;</code> 称为逻辑右移位: 低位溢出, 高位补0
<code>&gt;&gt;</code>  称为数学右移位: 低位溢出, 高位为0则补0 高位为1则补1</p>
<blockquote>
<p>如上两个计算正数时候没有差别, 负数有差别</p>
</blockquote>
<p>栗子:</p>
<pre><code>n =     00000000 00000000 00000000 00110010  50
m=n&gt;&gt;1  000000000 00000000 00000000 0011001  25
k=n&gt;&gt;2  0000000000 00000000 00000000 001100  12 小方向取整
</code></pre>

<p>负数:</p>
<pre><code>n =     11111111 11111111 11111111 11001110  -50
m=n&gt;&gt;1  111111111 11111111 11111111 1100111  -25
m=n&gt;&gt;2  1111111111 11111111 11111111 110011  -13 小方向取整

g=n&gt;&gt;&gt;1 011111111 11111111 11111111 1100111
</code></pre>

<p>验证右移位的数学意义:</p>
<pre><code>/**
 * 验证右移位的数学意义
 */
int n = -50;
int m = n&gt;&gt;1;
int k = n&gt;&gt;2;
int g = n&gt;&gt;&gt;1;
System.out.println(n);
System.out.println(m);
System.out.println(k);
System.out.println(g);
</code></pre>

<h2>面试</h2>
<p>经典面试题目</p>
<pre><code>优化计算 n % 16 为 (    )
答案: n &amp; 15  或 n &amp; 0xf
</code></pre>

<p>分析:</p>
<pre><code>n =  00011101 01010111 11010101 01110110
m =  00000000 00000000 00000000 00000111
n % 8 == n &amp; 7;
</code></pre>

<h2>作业</h2>
<ol>
<li>将一个long类型数据拆分为8个byte</li>
<li>将1题中的8个byte合并为一个long数据</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
